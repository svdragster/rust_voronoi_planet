//! Random point generation on sphere surface

use glam::Vec3;
use parry3d::math::Point;
use rand::{Rng, SeedableRng};
use rand_chacha::ChaCha8Rng;

/// Generate random points uniformly distributed on sphere surface
///
/// Uses deterministic RNG seeded with the provided seed for reproducibility.
/// Points are generated by normalizing random 3D vectors to the sphere surface.
///
/// # Arguments
///
/// * `count` - Number of points to generate
/// * `radius` - Sphere radius
/// * `seed` - Random seed for deterministic generation
///
/// # Returns
///
/// Vector of points on the sphere surface, suitable for Delaunay triangulation
pub fn generate_sphere_points(count: usize, radius: f32, seed: u32) -> Vec<Point<f32>> {
    let mut rng = ChaCha8Rng::seed_from_u64(seed as u64);

    (0..count)
        .map(|_| {
            // Generate random point in unit cube, then normalize to sphere
            let x: f32 = rng.gen_range(-1.0..1.0);
            let y: f32 = rng.gen_range(-1.0..1.0);
            let z: f32 = rng.gen_range(-1.0..1.0);

            // Normalize to sphere surface
            let vec = Vec3::new(x, y, z);
            let length = vec.length();

            if length > 0.0001 {
                let normalized = vec / length * radius;
                Point::new(normalized.x, normalized.y, normalized.z)
            } else {
                // Degenerate case: point at origin -> use default
                Point::new(radius, 0.0, 0.0)
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_sphere_points() {
        let points = generate_sphere_points(100, 10.0, 42);

        assert_eq!(points.len(), 100);

        // Verify all points are on sphere surface (within tolerance)
        for point in &points {
            let distance = (point.x * point.x + point.y * point.y + point.z * point.z).sqrt();
            assert!((distance - 10.0).abs() < 0.01, "Point not on sphere surface: distance={}", distance);
        }
    }

    #[test]
    fn test_determinism() {
        let points1 = generate_sphere_points(50, 10.0, 12345);
        let points2 = generate_sphere_points(50, 10.0, 12345);

        // Same seed should produce identical points
        assert_eq!(points1.len(), points2.len());
        for (p1, p2) in points1.iter().zip(points2.iter()) {
            assert_eq!(p1.x, p2.x);
            assert_eq!(p1.y, p2.y);
            assert_eq!(p1.z, p2.z);
        }
    }
}
